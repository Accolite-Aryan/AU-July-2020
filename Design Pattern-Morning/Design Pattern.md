## Interpreter Design Pattern

The Interpreter pattern discusses: defining a domain language (i.e. problem characterization) as a simple language grammar, representing domain rules as language sentences, and interpreting these sentences to solve the problem. The pattern uses a class to represent each grammar rule. And since grammars are usually hierarchical in structure, an inheritance hierarchy of rule classes maps nicely.
A class of problems occurs repeatedly in a well-defined and well-understood domain. If the domain were characterized with a "language", then problems could be easily solved with an interpretation "engine".

Interpreter design pattern is one of the behavioral design pattern. Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.

* This pattern involves implementing an expression interface which tells to interpret a particular context. This pattern is used in SQL parsing, symbol processing engine etc.
* This pattern performs upon a hierarchy of expressions. Each expression here is a terminal or non-terminal.
* The tree structure of Interpreter design pattern is somewhat similar to that defined by the composite design pattern with terminal expressions being leaf objects and non-terminal expressions being composites.
* The tree contains the expressions to be evaluated and is usually generated by a parser. The parser itself is not a part of the interpreter pattern.


An abstract base class specifies the method interpret(). Each concrete subclass implements interpret() by accepting (as an argument) the current state of the language stream, and adding its contribution to the problem solving process.


### Structure

Interpreter suggests modeling the domain with a recursive grammar. Each rule in the grammar is either a 'composite' (a rule that references other rules) or a terminal (a leaf node in a tree structure). Interpreter relies on the recursive traversal of the Composite pattern to interpret the 'sentences' it is asked to process.

### Implementation
An Interface Expression and concrete classes implementing the Expression interface. A class TerminalExpression is defined which acts as a main interpreter of context in question. Other classes OrExpression, AndExpression are used to create combinational expressions.

InterpreterPatternDemo, where demo class, will use Expression class to create rules and demonstrate parsing of expressions.

#### Step 1
##### Create an expression interface.

##### Expression.java

```
public interface Expression {
   public boolean interpret(String context);
}
```

#### Step 2
##### Create concrete classes implementing the above interface.

##### TerminalExpression.java

```
public class TerminalExpression implements Expression {
	
   private String data;

   public TerminalExpression(String data){
      this.data = data; 
   }

   @Override
   public boolean interpret(String context) {
   
      if(context.contains(data)){
         return true;
      }
      return false;
   }
}
```

##### OrExpression.java

```
public class OrExpression implements Expression {
	 
   private Expression expr1 = null;
   private Expression expr2 = null;

   public OrExpression(Expression expr1, Expression expr2) { 
      this.expr1 = expr1;
      this.expr2 = expr2;
   }

   @Override
   public boolean interpret(String context) {		
      return expr1.interpret(context) || expr2.interpret(context);
   }
}
```

##### AndExpression.java

```
public class AndExpression implements Expression {
	 
   private Expression expr1 = null;
   private Expression expr2 = null;

   public AndExpression(Expression expr1, Expression expr2) { 
      this.expr1 = expr1;
      this.expr2 = expr2;
   }

   @Override
   public boolean interpret(String context) {		
      return expr1.interpret(context) && expr2.interpret(context);
   }
}
```

#### Step 3

##### InterpreterPatternDemo uses Expression class to create rules and then parse them.

##### InterpreterPatternDemo.java

```
public class InterpreterPatternDemo {

   // C++ and JAVA are Object Oriented
   public static Expression getOOPLanguage(){
      Expression cpp = new TerminalExpression("C++");
      Expression java = new TerminalExpression("JAVA");
      return new OrExpression(cpp, java);		
   }

   //Python is Imperatively Derived from both
   public static Expression getImperativeDerivation(){
      Expression python = new TerminalExpression("Python");
      Expression imperative = new TerminalExpression("Imperative");
      return new AndExpression(python, imperative);		
   }

   public static void main(String[] args) {
      Expression isOOP = getOOPLanguage();
      Expression isImperative = getImperativeDerivation();

      System.out.println("Java is Object? " + isOOP.interpret("JAVA"));
      System.out.println("Python is Imperative? " + isImperative.interpret("Imperative Python"));
   }
}
```

#### Step 4
##### Verify the output.
```
John is male? true
Julie is a married women? true
```